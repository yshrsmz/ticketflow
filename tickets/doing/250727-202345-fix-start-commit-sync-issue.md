---
priority: 1
description: start時の親ブランチコミットとworktreeの同期問題を解決する
created_at: 2025-07-27T20:23:45.005609+09:00
started_at: 2025-07-27T20:26:07.59654+09:00
closed_at: null
---

# 概要

`ticketflow start`コマンド実行時に、親ブランチ側でチケットファイルの移動（todo→doing）をコミットしているが、このコミットがworktree側に含まれないため、以下の問題が発生している：

1. **チケットの重複**: worktree側ではtodoディレクトリに、親ブランチ側ではdoingディレクトリに同じチケットが存在する状態になる
2. **履歴の齟齬**: 親ブランチの`started_at`更新コミットがworktreeに反映されない
3. **マージ時の競合リスク**: 後でworktreeをマージする際に、チケットファイルの移動に関する競合が発生する可能性

## 現在の動作

1. `ticketflow start <ticket-id>`実行
2. worktree作成（L274: `app.Git.AddWorktree`）
3. 親ブランチで:
   - チケットをtodo→doingに移動（L345: `os.Rename`）
   - `started_at`を更新（L319: `t.Start()`）
   - コミット作成（L375: `app.Git.Commit`）
4. 結果: worktreeは手順2の時点の状態（コミット前）から分岐するため、todoにチケットが残る

## 解決案の詳細分析

### 案1: コミット順序の変更（チケット移動 → worktree作成）
**実装**:
1. チケットをtodo→doingに移動し、`started_at`を更新
2. 親ブランチでコミット作成
3. その後でworktree作成（最新のコミットから分岐）

**メリット**:
- 実装が単純（L274とL319-377の順序を入れ替えるだけ）
- worktreeに最新の状態が反映される
- 既存のロジックをほぼ維持できる

**デメリット**:
- コミット後にworktree作成が失敗した場合のロールバックが複雑
- 既にコミットしてしまっているため、戻すには`git reset`が必要

### 案2: チケット移動のコミットを廃止
**実装**:
- start時はファイル移動のコミットを作らない
- worktree内でのみチケットステータスを管理
- cleanup時にマージと同時にステータス更新

**メリット**:
- 親ブランチとworktreeの同期問題が根本的に解決
- シンプルな状態管理

**デメリット**:
- 親ブランチでは作業中のチケットが見えない（todoのまま）
- ワークフロー全体の見直しが必要
- 既存ユーザーへの影響大

### 案3: worktree作成後にrebase
**実装**:
1. 現状のまま親ブランチでコミット
2. worktree作成
3. worktree内で親ブランチの最新コミットをcherry-pickまたはrebase

**メリット**:
- 親ブランチの状態を正しく保てる
- worktreeも最新の状態になる

**デメリット**:
- 実装が複雑
- worktree内での追加のgit操作が必要
- エラーハンドリングが複雑

### 案4: worktree内でチケット移動を複製（推奨）
**実装**:
1. worktree作成（現状通り）
2. 親ブランチでチケット移動・コミット（現状通り）
3. worktree内でも同じチケット移動を実行（コミットなし）
4. worktree内のcurrent-ticket.mdシンボリックリンクを正しく設定

**メリット**:
- 実装が比較的シンプル（L385-408の処理を拡張）
- エラー時のロールバックが容易
- 親ブランチとworktreeの両方で正しい状態を維持
- 既存のワークフローを維持

**デメリット**:
- ファイル操作が2回必要
- worktree内のファイルは未コミット状態になる（これは許容範囲）

## 選択した解決案: 案1（コミット順序の変更）

案1を選択した理由:
- 最もシンプルで直感的な解決策
- Git的に正しいアプローチ（worktreeは最新コミットから作成される）
- 手動ファイル同期が不要
- worktree内に未コミット変更が残らない

## タスク
- [x] 現在のstart処理の実装を詳細に調査
- [x] 各解決案のメリット・デメリットを整理
- [x] 最適な解決方法を決定（案1）
- [x] 実装方針を策定
- [x] テストケースを設計
- [x] 実装
- [x] 既存のworktreeへの影響を考慮

## 実装内容（完了）

### 1. 修正内容
`internal/cli/commands.go`のStartTicket関数で、コミット順序を変更：

**変更前の順序:**
1. worktree作成
2. チケット移動・コミット
3. 手動でファイル同期

**変更後の順序:**
1. チケット移動・コミット
2. worktree作成（最新コミットから）
3. 手動同期は不要（削除）

### 2. 具体的な変更
- L262-304: worktree作成処理を後方に移動
- L333-388: コミット後にworktree作成するよう変更
- L385-416: 手動ファイル同期コードを削除
- エラーハンドリング: worktree作成失敗時は`git reset --hard HEAD^`でロールバック

### 3. テスト
- 新しいテスト`TestStartTicket_WorktreeCreatedAfterCommit`を追加
- worktreeが最新状態で作成されることを確認
- worktree内に未コミット変更がないことを確認

## 技術仕様

### 影響範囲
- `internal/cli/commands.go`: StartTicket関数の処理順序変更

### 考慮事項
- 既存のワークフローとの互換性（維持される）
- ユーザーの期待する動作（worktreeが最新状態で作成される）
- Gitの履歴の整合性（親ブランチのコミットは維持）
- worktree内がクリーンな状態（未コミット変更なし）

## メモ

- この問題は優先度高（priority: 1）として設定
- worktreeベースの開発フローの根幹に関わる問題
- 案1の実装により、よりシンプルで保守しやすいコードになった